---
title: celery
date: 2021-08-02 11:12:26
permalink: /python/premium/dDYPqISkJUAuuWm1no/
---



## 使用celery常见问题



### 1、在数据库事务中入列任务、在任务中使用数据库事务

虽然你可能认为Celery是用来“稍后/最终”执行任务的，但是它也可以很快地执行它们!如果你从数据库事务中入列一个任务，难么它可能会在数据库提交事务之前执行。这可能意味着你的任务需要访问的数据，例如一个新的模型实例，是不可见的，并且它还会引发一个DoesNotExist异常。

解决方案是使用Django的transaction.on_commit来在事务提交后入列你的任务。Django文档和Celery文档都很好地描述了这一点。

另一点在任务中使用数据库事务，虽然Django使在视图中通过ATOMIC_REQUESTS使用数据库事务变得容易，但是对于views的代码，你就得靠自己了。这包括Celery任务。如果你没有使用transaction.atomic()包装你的任务，或者在你的任务体中使用它，那么你可能会遇到数据完整性问题。

为了找到应该在哪里使用transaction.atomic()，审查一下你的任务是值得的。你甚至可以为Celery的@shared_task添加一个特定于项目的包装器，它可以将@atomic添加到你的任务中。



### 2、给任务指定了一个很长的countdown或一个eta

Celery为任务队列提供了eta和countdown参数。这些参数允许你对任务进行计划以便稍后执行。

不幸的是，这些工作方式并没有被内置到代理中。这些延迟的任务最终会排在队列的最前面，排在后面的非延迟任务之前。Celery工作进程会获取延迟的任务并在内存中将它们“放在一边”，然后再获取非延迟的任务。

如果这样的任务过多，Celery工作进程将使用大量内存来保存这些任务。重新启动工作进程还需要重新获取队列头部的所有延迟的任务。我见过这样的情况，其中有大量的延迟任务，重新启动花费了几分钟才开始做实际的工作!

如果你需要延迟任务超过几分钟，你应该避免eta和countdown。最好是向你的模型实例中添加一个字段，并指定要执行的时间，然后使用一个定期任务对实例执行即时入列。



### 3、ACKS行为

Celery的默认行为是立即确认任务，不管是否完成了任务，同时从你的代理队列中将它们删除。如果它们被中断，例如被一个随机的服务器崩溃中断，那么Celery将不会重试这个任务。

如果你的任务是幂等的(可重复而不会出问题)，这种行为是很好的。但它不适用于处理随机错误，比如你的数据库连接随机断开。在这种情况下，你的工作就会丢失，因为Celery在尝试它之前就把它从队列中删除了。

相反的行为，“延迟确认”，只在任务成功完成后进行确认。这是其他许多队列系统(如SQS)所推荐的行为。

Celery在它的FAQ“我应该使用重试还是acks_late?”中对这一点进行了介绍。这是一个微妙的问题，但我确实认为默认的“提前确认”行为是违反直觉的。

我建议你在Celery配置中将acks_late = True设置为默认值，并充分考虑哪种模式适合每个任务。你可以通过将acks_late传递给@shared_task装饰器来在每个任务函数上重新配置它。



### 4、不重试漏掉的任务

任务可能会因为各种各样的原因而崩溃，而其中的许多任务是你无法控制的。例如，如果你的数据库服务器崩溃了，Celery可能就无法执行任务，并且会引发一个“连接失败”错误。

解决这个问题最简单的方法是使用第二个定期的“清理器任务”，它将扫描并重复/重新入列漏掉的任务。AWS最近的一篇文章[《避免无法克服的队列积压》](https://aws.amazon.com/cn/builders-library/avoiding-insurmountable-queue-backlogs/)中指出，他们把这类任务称为“逆熵清理器”。(那篇文章读起来棒极了，里面满是关于规模化处理队列的建议。)



### 5、以向后不兼容的方式更改任务签名

如果你要添加一个新参数，首先给它一个默认值——类似于为数据库添加可为空的列。当该版本的代码运行后，你就可以删除默认值。

类似地，如果你要删除一个参数，你首先得给它一个默认值。

如果你要删除一个任务，首先删除调用位置，然后再删除任务本身。